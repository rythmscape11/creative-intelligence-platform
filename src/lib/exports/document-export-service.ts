/**
 * Free Document Export Service
 * Uses open-source npm libraries - NO paid APIs required!
 * 
 * Libraries used:
 * - jsPDF (already installed) - PDF generation
 * - docx - Word document generation  
 * - pptxgenjs - PowerPoint generation
 * 
 * All libraries run locally, no API keys needed!
 */

import jsPDF from 'jspdf';
import 'jspdf-autotable';
import {
    Document,
    Packer,
    Paragraph,
    TextRun,
    HeadingLevel,
    Table,
    TableRow,
    TableCell,
    WidthType,
    AlignmentType,
    BorderStyle,
} from 'docx';
import PptxGenJS from 'pptxgenjs';

// Extend jsPDF with autotable
declare module 'jspdf' {
    interface jsPDF {
        autoTable: (options: any) => jsPDF;
        lastAutoTable: { finalY: number };
    }
}

export type ExportFormat = 'pdf' | 'docx' | 'pptx';

export interface StrategyData {
    title: string;
    businessName?: string;
    industry?: string;
    budget?: number;
    executiveSummary?: string;
    targetAudience?: string;
    objectives?: string[];
    channels?: Array<{ name: string; allocation: number; budget?: number }>;
    tactics?: string[];
    kpis?: string[];
    timeline?: string;
    createdAt?: Date;
}

export interface ExportResult {
    success: boolean;
    fileName: string;
    dataUri?: string;
    blob?: Blob;
    error?: string;
}

/**
 * Free Document Export Service
 * All methods use open-source libraries, no API costs!
 */
export class FreeDocumentExportService {

    /**
     * Generate PDF using jsPDF (FREE)
     */
    static async generatePDF(data: StrategyData): Promise<ExportResult> {
        try {
            const doc = new jsPDF();
            const pageWidth = doc.internal.pageSize.getWidth();
            let yPosition = 20;

            // Header with gradient-like background
            doc.setFillColor(99, 102, 241); // Indigo
            doc.rect(0, 0, pageWidth, 45, 'F');

            // Title
            doc.setTextColor(255, 255, 255);
            doc.setFontSize(24);
            doc.setFont('helvetica', 'bold');
            doc.text(data.title || 'Marketing Strategy', pageWidth / 2, 25, { align: 'center' });

            // Subtitle
            doc.setFontSize(10);
            doc.setFont('helvetica', 'normal');
            doc.text(`Generated by MediaPlanPro • ${new Date().toLocaleDateString()}`, pageWidth / 2, 35, { align: 'center' });

            yPosition = 55;
            doc.setTextColor(30, 41, 59);

            // Key Metrics Box
            if (data.businessName || data.industry || data.budget) {
                doc.setFillColor(248, 250, 252);
                doc.roundedRect(15, yPosition, pageWidth - 30, 30, 3, 3, 'F');

                doc.setFontSize(10);
                let xPos = 25;

                if (data.businessName) {
                    doc.setFont('helvetica', 'bold');
                    doc.text('Business:', xPos, yPosition + 12);
                    doc.setFont('helvetica', 'normal');
                    doc.text(data.businessName, xPos + 25, yPosition + 12);
                    xPos += 70;
                }

                if (data.industry) {
                    doc.setFont('helvetica', 'bold');
                    doc.text('Industry:', xPos, yPosition + 12);
                    doc.setFont('helvetica', 'normal');
                    doc.text(data.industry, xPos + 22, yPosition + 12);
                    xPos += 60;
                }

                if (data.budget) {
                    doc.setFont('helvetica', 'bold');
                    doc.text('Budget:', xPos, yPosition + 12);
                    doc.setFont('helvetica', 'normal');
                    doc.text(`$${data.budget.toLocaleString()}`, xPos + 20, yPosition + 12);
                }

                yPosition += 40;
            }

            // Executive Summary
            if (data.executiveSummary) {
                doc.setFontSize(14);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(99, 102, 241);
                doc.text('Executive Summary', 15, yPosition);
                yPosition += 8;

                doc.setFontSize(10);
                doc.setFont('helvetica', 'normal');
                doc.setTextColor(30, 41, 59);
                const summaryLines = doc.splitTextToSize(data.executiveSummary, pageWidth - 30);
                doc.text(summaryLines, 15, yPosition);
                yPosition += summaryLines.length * 5 + 10;
            }

            // Objectives Section
            if (data.objectives && data.objectives.length > 0) {
                if (yPosition > 240) {
                    doc.addPage();
                    yPosition = 20;
                }

                doc.setFontSize(14);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(99, 102, 241);
                doc.text('Strategic Objectives', 15, yPosition);
                yPosition += 8;

                doc.setFontSize(10);
                doc.setFont('helvetica', 'normal');
                doc.setTextColor(30, 41, 59);
                data.objectives.forEach((obj, i) => {
                    doc.text(`${i + 1}. ${obj}`, 20, yPosition);
                    yPosition += 6;
                });
                yPosition += 5;
            }

            // Channel Allocation Table
            if (data.channels && data.channels.length > 0) {
                if (yPosition > 200) {
                    doc.addPage();
                    yPosition = 20;
                }

                doc.setFontSize(14);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(99, 102, 241);
                doc.text('Channel Allocation', 15, yPosition);
                yPosition += 5;

                (doc as any).autoTable({
                    startY: yPosition,
                    head: [['Channel', 'Allocation', 'Budget']],
                    body: data.channels.map(ch => [
                        ch.name,
                        `${ch.allocation}%`,
                        ch.budget ? `$${ch.budget.toLocaleString()}` : '-'
                    ]),
                    theme: 'striped',
                    headStyles: { fillColor: [99, 102, 241] },
                    margin: { left: 15, right: 15 },
                });

                yPosition = (doc as any).lastAutoTable.finalY + 10;
            }

            // KPIs Section
            if (data.kpis && data.kpis.length > 0) {
                if (yPosition > 240) {
                    doc.addPage();
                    yPosition = 20;
                }

                doc.setFontSize(14);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(99, 102, 241);
                doc.text('Key Performance Indicators', 15, yPosition);
                yPosition += 8;

                doc.setFontSize(10);
                doc.setFont('helvetica', 'normal');
                doc.setTextColor(30, 41, 59);
                data.kpis.forEach((kpi) => {
                    doc.text(`• ${kpi}`, 20, yPosition);
                    yPosition += 6;
                });
            }

            // Footer on all pages
            const pageCount = doc.getNumberOfPages();
            for (let i = 1; i <= pageCount; i++) {
                doc.setPage(i);
                doc.setFontSize(8);
                doc.setTextColor(150);
                doc.text(
                    `Page ${i} of ${pageCount} | Generated by MediaPlanPro`,
                    pageWidth / 2,
                    doc.internal.pageSize.getHeight() - 10,
                    { align: 'center' }
                );
            }

            const fileName = `${data.title?.replace(/[^a-z0-9]/gi, '-') || 'strategy'}-${Date.now()}.pdf`;
            const dataUri = doc.output('datauristring');

            return {
                success: true,
                fileName,
                dataUri,
            };
        } catch (error) {
            console.error('PDF generation error:', error);
            return {
                success: false,
                fileName: '',
                error: error instanceof Error ? error.message : 'PDF generation failed',
            };
        }
    }

    /**
     * Generate DOCX using docx library (FREE)
     */
    static async generateDOCX(data: StrategyData): Promise<ExportResult> {
        try {
            const sections = [];

            // Title
            sections.push(
                new Paragraph({
                    children: [
                        new TextRun({
                            text: data.title || 'Marketing Strategy',
                            bold: true,
                            size: 48,
                            color: '6366F1',
                        }),
                    ],
                    heading: HeadingLevel.TITLE,
                    alignment: AlignmentType.CENTER,
                }),
                new Paragraph({
                    children: [
                        new TextRun({
                            text: `Generated by MediaPlanPro • ${new Date().toLocaleDateString()}`,
                            size: 20,
                            color: '64748b',
                        }),
                    ],
                    alignment: AlignmentType.CENTER,
                }),
                new Paragraph({ text: '' }) // Spacer
            );

            // Business Info
            if (data.businessName || data.industry || data.budget) {
                sections.push(
                    new Paragraph({
                        children: [
                            new TextRun({ text: 'Business: ', bold: true }),
                            new TextRun({ text: data.businessName || 'N/A' }),
                            new TextRun({ text: '  |  Industry: ', bold: true }),
                            new TextRun({ text: data.industry || 'N/A' }),
                            new TextRun({ text: '  |  Budget: ', bold: true }),
                            new TextRun({ text: data.budget ? `$${data.budget.toLocaleString()}` : 'N/A' }),
                        ],
                    }),
                    new Paragraph({ text: '' })
                );
            }

            // Executive Summary
            if (data.executiveSummary) {
                sections.push(
                    new Paragraph({
                        children: [
                            new TextRun({ text: 'Executive Summary', bold: true, size: 28, color: '6366F1' }),
                        ],
                        heading: HeadingLevel.HEADING_1,
                    }),
                    new Paragraph({ text: data.executiveSummary }),
                    new Paragraph({ text: '' })
                );
            }

            // Objectives
            if (data.objectives && data.objectives.length > 0) {
                sections.push(
                    new Paragraph({
                        children: [
                            new TextRun({ text: 'Strategic Objectives', bold: true, size: 28, color: '6366F1' }),
                        ],
                        heading: HeadingLevel.HEADING_1,
                    })
                );
                data.objectives.forEach((obj, i) => {
                    sections.push(
                        new Paragraph({
                            children: [new TextRun({ text: `${i + 1}. ${obj}` })],
                            bullet: { level: 0 },
                        })
                    );
                });
                sections.push(new Paragraph({ text: '' }));
            }

            // Channel Allocation Table
            if (data.channels && data.channels.length > 0) {
                sections.push(
                    new Paragraph({
                        children: [
                            new TextRun({ text: 'Channel Allocation', bold: true, size: 28, color: '6366F1' }),
                        ],
                        heading: HeadingLevel.HEADING_1,
                    })
                );

                const table = new Table({
                    width: { size: 100, type: WidthType.PERCENTAGE },
                    rows: [
                        new TableRow({
                            children: [
                                new TableCell({
                                    children: [new Paragraph({ children: [new TextRun({ text: 'Channel', bold: true })] })],
                                    shading: { fill: '6366F1' },
                                }),
                                new TableCell({
                                    children: [new Paragraph({ children: [new TextRun({ text: 'Allocation', bold: true })] })],
                                    shading: { fill: '6366F1' },
                                }),
                                new TableCell({
                                    children: [new Paragraph({ children: [new TextRun({ text: 'Budget', bold: true })] })],
                                    shading: { fill: '6366F1' },
                                }),
                            ],
                        }),
                        ...data.channels.map(ch => new TableRow({
                            children: [
                                new TableCell({ children: [new Paragraph({ text: ch.name })] }),
                                new TableCell({ children: [new Paragraph({ text: `${ch.allocation}%` })] }),
                                new TableCell({ children: [new Paragraph({ text: ch.budget ? `$${ch.budget.toLocaleString()}` : '-' })] }),
                            ],
                        })),
                    ],
                });
                sections.push(table, new Paragraph({ text: '' }));
            }

            // KPIs
            if (data.kpis && data.kpis.length > 0) {
                sections.push(
                    new Paragraph({
                        children: [
                            new TextRun({ text: 'Key Performance Indicators', bold: true, size: 28, color: '6366F1' }),
                        ],
                        heading: HeadingLevel.HEADING_1,
                    })
                );
                data.kpis.forEach(kpi => {
                    sections.push(
                        new Paragraph({
                            children: [new TextRun({ text: kpi })],
                            bullet: { level: 0 },
                        })
                    );
                });
            }

            const doc = new Document({
                sections: [{ children: sections }],
            });

            const blob = await Packer.toBlob(doc);
            const fileName = `${data.title?.replace(/[^a-z0-9]/gi, '-') || 'strategy'}-${Date.now()}.docx`;

            // Convert blob to data URI
            const dataUri = await new Promise<string>((resolve) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result as string);
                reader.readAsDataURL(blob);
            });

            return {
                success: true,
                fileName,
                dataUri,
                blob,
            };
        } catch (error) {
            console.error('DOCX generation error:', error);
            return {
                success: false,
                fileName: '',
                error: error instanceof Error ? error.message : 'DOCX generation failed',
            };
        }
    }

    /**
     * Generate PPTX using pptxgenjs (FREE)
     */
    static async generatePPTX(data: StrategyData): Promise<ExportResult> {
        try {
            const pptx = new PptxGenJS();
            pptx.author = 'MediaPlanPro';
            pptx.title = data.title || 'Marketing Strategy';
            pptx.subject = 'Marketing Strategy Presentation';

            // Title Slide
            const slide1 = pptx.addSlide();
            slide1.addText(data.title || 'Marketing Strategy', {
                x: 0.5,
                y: 2,
                w: 9,
                h: 1.5,
                fontSize: 44,
                bold: true,
                color: '6366F1',
                align: 'center',
            });
            slide1.addText(`${data.businessName || ''} | ${data.industry || ''}`, {
                x: 0.5,
                y: 3.5,
                w: 9,
                h: 0.5,
                fontSize: 18,
                color: '64748b',
                align: 'center',
            });
            slide1.addText(`Generated by MediaPlanPro • ${new Date().toLocaleDateString()}`, {
                x: 0.5,
                y: 5,
                w: 9,
                h: 0.3,
                fontSize: 12,
                color: '94a3b8',
                align: 'center',
            });

            // Executive Summary Slide
            if (data.executiveSummary) {
                const slide2 = pptx.addSlide();
                slide2.addText('Executive Summary', {
                    x: 0.5,
                    y: 0.3,
                    w: 9,
                    h: 0.7,
                    fontSize: 32,
                    bold: true,
                    color: '6366F1',
                });
                slide2.addText(data.executiveSummary, {
                    x: 0.5,
                    y: 1.2,
                    w: 9,
                    h: 4,
                    fontSize: 16,
                    color: '334155',
                    valign: 'top',
                });
            }

            // Key Metrics Slide
            const slide3 = pptx.addSlide();
            slide3.addText('Key Metrics', {
                x: 0.5,
                y: 0.3,
                w: 9,
                h: 0.7,
                fontSize: 32,
                bold: true,
                color: '6366F1',
            });

            // Metric boxes
            const metrics = [
                { label: 'Total Budget', value: data.budget ? `$${data.budget.toLocaleString()}` : 'N/A' },
                { label: 'Channels', value: data.channels?.length?.toString() || '0' },
                { label: 'Objectives', value: data.objectives?.length?.toString() || '0' },
            ];

            metrics.forEach((metric, i) => {
                slide3.addShape('rect', {
                    x: 0.5 + (i * 3.2),
                    y: 1.5,
                    w: 2.8,
                    h: 1.5,
                    fill: { color: 'F1F5F9' },
                    line: { color: 'E2E8F0' },
                });
                slide3.addText(metric.value, {
                    x: 0.5 + (i * 3.2),
                    y: 1.6,
                    w: 2.8,
                    h: 0.7,
                    fontSize: 28,
                    bold: true,
                    color: '1E293B',
                    align: 'center',
                });
                slide3.addText(metric.label, {
                    x: 0.5 + (i * 3.2),
                    y: 2.3,
                    w: 2.8,
                    h: 0.5,
                    fontSize: 14,
                    color: '64748b',
                    align: 'center',
                });
            });

            // Channel Allocation Slide
            if (data.channels && data.channels.length > 0) {
                const slide4 = pptx.addSlide();
                slide4.addText('Channel Allocation', {
                    x: 0.5,
                    y: 0.3,
                    w: 9,
                    h: 0.7,
                    fontSize: 32,
                    bold: true,
                    color: '6366F1',
                });

                // Create table rows in the correct format for pptxgenjs
                const tableRows: any[][] = [
                    [
                        { text: 'Channel', options: { bold: true, fill: { color: '6366F1' }, color: 'FFFFFF' } },
                        { text: 'Allocation', options: { bold: true, fill: { color: '6366F1' }, color: 'FFFFFF' } },
                        { text: 'Budget', options: { bold: true, fill: { color: '6366F1' }, color: 'FFFFFF' } }
                    ],
                    ...data.channels.map(ch => [
                        { text: ch.name },
                        { text: `${ch.allocation}%` },
                        { text: ch.budget ? `$${ch.budget.toLocaleString()}` : '-' }
                    ]),
                ];

                slide4.addTable(tableRows, {
                    x: 0.5,
                    y: 1.2,
                    w: 9,
                    colW: [4, 2.5, 2.5],
                    fontSize: 14,
                    border: { pt: 1, color: 'E2E8F0' },
                });
            }

            // Thank You Slide
            const slideLast = pptx.addSlide();
            slideLast.addText('Thank You', {
                x: 0.5,
                y: 2.5,
                w: 9,
                h: 1,
                fontSize: 44,
                bold: true,
                color: '6366F1',
                align: 'center',
            });
            slideLast.addText('Generated by MediaPlanPro', {
                x: 0.5,
                y: 3.8,
                w: 9,
                h: 0.5,
                fontSize: 16,
                color: '64748b',
                align: 'center',
            });

            const fileName = `${data.title?.replace(/[^a-z0-9]/gi, '-') || 'strategy'}-${Date.now()}.pptx`;

            // Generate base64 data
            const pptxData = await pptx.write({ outputType: 'base64' });
            const dataUri = `data:application/vnd.openxmlformats-officedocument.presentationml.presentation;base64,${pptxData}`;

            return {
                success: true,
                fileName,
                dataUri,
            };
        } catch (error) {
            console.error('PPTX generation error:', error);
            return {
                success: false,
                fileName: '',
                error: error instanceof Error ? error.message : 'PPTX generation failed',
            };
        }
    }

    /**
     * Export strategy in any format
     */
    static async export(data: StrategyData, format: ExportFormat): Promise<ExportResult> {
        switch (format) {
            case 'pdf':
                return this.generatePDF(data);
            case 'docx':
                return this.generateDOCX(data);
            case 'pptx':
                return this.generatePPTX(data);
            default:
                return {
                    success: false,
                    fileName: '',
                    error: `Unsupported format: ${format}`,
                };
        }
    }
}

export default FreeDocumentExportService;
